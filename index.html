<!doctype html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>靈魂星雲 | Soul Nebula Fluid</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #020205;
        font-family: "Segoe UI", system-ui, sans-serif;
      }
      canvas {
        display: block;
      }
      #overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: #fff;
        background: radial-gradient(circle at center, rgba(10, 0, 30, 0.85) 0%, #000 100%);
        cursor: pointer;
        z-index: 100;
        transition: all 1s ease-in-out;
      }
      #overlay.hidden {
        opacity: 0;
        pointer-events: none;
        transform: scale(1.5);
      }
      .container {
        text-align: center;
        padding: 30px;
        border-radius: 20px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        max-width: 85vw;
        box-sizing: border-box;
      }
      h1 {
        font-weight: 200;
        letter-spacing: 12px;
        margin: 0;
        background: linear-gradient(45deg, #00d2ff, #9d50bb);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-size: 2.5rem;
      }
      .hint {
        margin-top: 15px;
        color: rgba(255, 255, 255, 0.5);
        font-size: 10px;
        letter-spacing: 3px;
        text-transform: uppercase;
      }
      @media (max-width: 480px) {
        .container {
          padding: 24px 20px;
        }
        h1 {
          font-size: 1.5rem;
          letter-spacing: 6px;
        }
        .hint {
          font-size: 9px;
          letter-spacing: 2px;
        }
      }
    </style>
  </head>
  <body>
    <div id="overlay">
      <div class="container">
        <h1>SOUL NEBULA</h1>
        <div class="hint">Click to Connect Audio Stream</div>
      </div>
    </div>

    <script id="vertexShader" type="x-shader/x-vertex">
      varying vec2 vUv;
      void main() {
          vUv = uv;
          gl_Position = vec4(position, 1.0);
      }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
      precision highp float;
      uniform float uTime;
      uniform vec2 uResolution;
      uniform vec2 uMouse;
      uniform float uAudioIntensity;
      uniform float uBass;
      uniform float uTreble;
      varying vec2 vUv;

      // 偽隨機函數
      float hash(vec2 p) {
          return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
      }

      // 2D 噪點
      float noise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          vec2 u = f * f * (3.0 - 2.0 * f);
          return mix(mix(hash(i + vec2(0.0, 0.0)), hash(i + vec2(1.0, 0.0)), u.x),
                     mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), u.x), u.y);
      }

      // 分形布朗運動 (FBM)
      float fbm(vec2 p) {
          float v = 0.0;
          float a = 0.5;
          vec2 shift = vec2(100.0);
          mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));
          for (int i = 0; i < 6; ++i) {
              v += a * noise(p);
              p = rot * p * 2.0 + shift;
              a *= 0.5;
          }
          return v;
      }

      void main() {
          vec2 uv = (gl_FragCoord.xy * 2.0 - uResolution.xy) / min(uResolution.x, uResolution.y);

          // 滑鼠互動影響力
          float distToMouse = length(uv - uMouse * 0.5);

          // 域扭曲 (Domain Warping)
          vec2 q = vec2(0.0);
          q.x = fbm(uv + 0.1 * uTime + uBass * 0.2);
          q.y = fbm(uv + vec2(1.0));

          vec2 r = vec2(0.0);
          r.x = fbm(uv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * uTime);
          r.y = fbm(uv + 1.0 * q + vec2(8.3, 2.8) + 0.126 * uTime);

          float f = fbm(uv + r + uTreble * 0.3);

          // 色彩設計
          vec3 col = vec3(0.0);

          // 基礎背景色
          col = mix(vec3(0.05, 0.0, 0.1), vec3(0.1, 0.2, 0.4), f);

          // 核心流動色彩 (隨音頻變化)
          vec3 nebulaColor1 = vec3(0.1, 0.5, 0.8); // 青藍
          vec3 nebulaColor2 = vec3(0.8, 0.2, 0.9); // 紫紅

          vec3 dynamicCol = mix(nebulaColor1, nebulaColor2, clamp(uBass * 2.0, 0.0, 1.0));
          col = mix(col, dynamicCol, pow(q.x, 2.0));

          // 亮部邊緣
          col = mix(col, vec3(0.5, 1.0, 1.0), pow(r.y, 3.0) * (1.0 + uTreble));

          // 增加亮點與對比
          float intensity = f * f * (3.0 - 2.0 * f);
          col += intensity * 0.2 * uAudioIntensity;

          // 加入微細顆粒 (隨高音閃爍)
          float grain = hash(uv + uTime) * 0.05 * uTreble;
          col += grain;

          // 邊緣柔化
          float edge = smoothstep(1.5, 0.0, length(uv));

          gl_FragColor = vec4(col * edge, 1.0);
      }
    </script>

    <script>
      let scene, camera, renderer, material;
      let audioContext, analyser, dataArray;
      let mouse = new THREE.Vector2(0, 0);
      let targetMouse = new THREE.Vector2(0, 0);

      let smoothBass = 0,
        smoothTreble = 0,
        smoothIntensity = 0;

      function initScene() {
        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        const geometry = new THREE.PlaneGeometry(2, 2);
        material = new THREE.ShaderMaterial({
          uniforms: {
            uTime: { value: 0 },
            uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
            uMouse: { value: new THREE.Vector2(0, 0) },
            uAudioIntensity: { value: 0 },
            uBass: { value: 0 },
            uTreble: { value: 0 },
          },
          vertexShader: document.getElementById("vertexShader").textContent,
          fragmentShader: document.getElementById("fragmentShader").textContent,
        });

        scene.add(new THREE.Mesh(geometry, material));

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        window.addEventListener("resize", () => {
          renderer.setSize(window.innerWidth, window.innerHeight);
          material.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
        });

        window.addEventListener("mousemove", (e) => {
          targetMouse.x = (e.clientX / window.innerWidth) * 2 - 1;
          targetMouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });
      }

      async function initAudio() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioContext.createMediaStreamSource(stream);
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 512;
          source.connect(analyser);
          dataArray = new Uint8Array(analyser.frequencyBinCount);
          return true;
        } catch (err) {
          console.error("Audio Access Denied:", err);
          return false;
        }
      }

      function animate(time) {
        requestAnimationFrame(animate);

        if (analyser) {
          analyser.getByteFrequencyData(dataArray);
          let b = 0,
            t = 0,
            s = 0;
          const len = dataArray.length;

          for (let i = 0; i < 15; i++) b += dataArray[i];
          for (let i = Math.floor(len * 0.7); i < len; i++) t += dataArray[i];
          for (let i = 0; i < len; i++) s += dataArray[i];

          smoothBass += (b / 15 / 255 - smoothBass) * 0.12;
          smoothTreble += (t / (len * 0.3) / 255 - smoothTreble) * 0.15;
          smoothIntensity += (s / len / 255 - smoothIntensity) * 0.1;

          material.uniforms.uBass.value = smoothBass;
          material.uniforms.uTreble.value = smoothTreble;
          material.uniforms.uAudioIntensity.value = smoothIntensity;
        }

        mouse.lerp(targetMouse, 0.05);
        material.uniforms.uMouse.value.copy(mouse);
        material.uniforms.uTime.value = time * 0.001;
        renderer.render(scene, camera);
      }

      document.getElementById("overlay").addEventListener("click", async () => {
        if (await initAudio()) {
          document.getElementById("overlay").classList.add("hidden");
          initScene();
          animate(0);
        }
      });
    </script>
  </body>
</html>
