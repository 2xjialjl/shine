<!doctype html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>烈焰之魂 | Soul Flame</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #020205;
        font-family: "Segoe UI", system-ui, sans-serif;
      }
      canvas {
        display: block;
      }
      #overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: #fff;
        background: radial-gradient(circle at center, rgba(30, 5, 0, 0.85) 0%, #000 100%);
        cursor: pointer;
        z-index: 100;
        transition: all 1s ease-in-out;
      }
      #overlay.hidden {
        opacity: 0;
        pointer-events: none;
        transform: scale(1.5);
      }
      .container {
        text-align: center;
        padding: 30px;
        border-radius: 20px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        max-width: 85vw;
        box-sizing: border-box;
      }
      h1 {
        font-weight: 200;
        letter-spacing: 12px;
        margin: 0;
        background: linear-gradient(45deg, #ff6a00, #ff2200);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-size: 2.5rem;
      }
      .hint {
        margin-top: 15px;
        color: rgba(255, 255, 255, 0.5);
        font-size: 10px;
        letter-spacing: 3px;
        text-transform: uppercase;
      }
      @media (max-width: 480px) {
        .container {
          padding: 24px 20px;
        }
        h1 {
          font-size: 1.5rem;
          letter-spacing: 6px;
        }
        .hint {
          font-size: 9px;
          letter-spacing: 2px;
        }
      }
    </style>
  </head>
  <body>
    <div id="overlay">
      <div class="container">
        <h1>SOUL FLAME</h1>
        <div class="hint">Click to Ignite</div>
      </div>
    </div>

    <script id="vertexShader" type="x-shader/x-vertex">
      varying vec2 vUv;
      void main() {
          vUv = uv;
          gl_Position = vec4(position, 1.0);
      }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
      precision highp float;
      uniform float uTime;
      uniform vec2 uResolution;
      uniform vec2 uMouse;
      uniform float uAudioIntensity;
      uniform float uBass;
      uniform float uTreble;
      varying vec2 vUv;

      // 偽隨機函數
      float hash(vec2 p) {
          return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
      }

      // 2D 噪點
      float noise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          vec2 u = f * f * (3.0 - 2.0 * f);
          return mix(mix(hash(i + vec2(0.0, 0.0)), hash(i + vec2(1.0, 0.0)), u.x),
                     mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), u.x), u.y);
      }

      // 分形布朗運動 (FBM)
      float fbm(vec2 p) {
          float v = 0.0;
          float a = 0.5;
          vec2 shift = vec2(100.0);
          mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));
          for (int i = 0; i < 6; ++i) {
              v += a * noise(p);
              p = rot * p * 2.0 + shift;
              a *= 0.5;
          }
          return v;
      }

      void main() {
          vec2 uv = (gl_FragCoord.xy * 2.0 - uResolution.xy) / min(uResolution.x, uResolution.y);

          // 火焰向上飄動：y 軸加時間偏移
          vec2 fireUV = uv;
          fireUV.y += uTime * 0.8 + uBass * 0.5;

          // 滑鼠互動：輕微擾動火焰
          fireUV += uMouse * 0.1;

          // 域扭曲產生火焰紋理
          vec2 q = vec2(0.0);
          q.x = fbm(fireUV * 1.5 + uTime * 0.3);
          q.y = fbm(fireUV * 1.5 + vec2(5.2, 1.3));

          vec2 r = vec2(0.0);
          r.x = fbm(fireUV * 2.0 + q + vec2(1.7, 9.2) + uTime * 0.2);
          r.y = fbm(fireUV * 2.0 + q + vec2(8.3, 2.8) + uTime * 0.15);

          float f = fbm(fireUV * 1.5 + r + uTreble * 0.5);

          // 火焰形狀：底部亮、頂部暗
          float flameShape = 1.0 - smoothstep(-0.5, 1.5, uv.y);
          // 水平收窄
          flameShape *= smoothstep(1.2, 0.0, abs(uv.x) * (1.0 + uv.y * 0.5));

          // 火焰強度
          float fireIntensity = f * flameShape;
          fireIntensity = pow(fireIntensity, 1.5) * (2.0 + uBass * 3.0);

          // 火焰色彩：白芯 → 黃 → 橘 → 紅 → 暗紅
          vec3 col = vec3(0.0);
          col = mix(vec3(0.1, 0.0, 0.0), vec3(0.9, 0.1, 0.0), clamp(fireIntensity, 0.0, 1.0));
          col = mix(col, vec3(1.0, 0.6, 0.0), clamp(fireIntensity - 0.4, 0.0, 1.0));
          col = mix(col, vec3(1.0, 0.9, 0.5), clamp(fireIntensity - 0.8, 0.0, 1.0));
          col = mix(col, vec3(1.0, 1.0, 0.9), clamp(fireIntensity - 1.2, 0.0, 1.0));

          // 高音帶出火花閃爍
          float spark = hash(uv * 10.0 + uTime * 3.0);
          if(spark > 0.97) col += vec3(1.0, 0.8, 0.3) * uTreble * flameShape;

          // 底部餘燼光暈
          float ember = exp(-length(vec2(uv.x, uv.y + 0.8)) * 3.0);
          col += vec3(0.6, 0.1, 0.0) * ember * (0.5 + uBass);

          // 整體音頻亮度提升
          col += col * uAudioIntensity * 0.3;

          gl_FragColor = vec4(col, 1.0);
      }
    </script>

    <script>
      let scene, camera, renderer, material;
      let audioContext, analyser, dataArray;
      let mouse = new THREE.Vector2(0, 0);
      let targetMouse = new THREE.Vector2(0, 0);

      let smoothBass = 0,
        smoothTreble = 0,
        smoothIntensity = 0;

      function initScene() {
        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        const geometry = new THREE.PlaneGeometry(2, 2);
        material = new THREE.ShaderMaterial({
          uniforms: {
            uTime: { value: 0 },
            uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
            uMouse: { value: new THREE.Vector2(0, 0) },
            uAudioIntensity: { value: 0 },
            uBass: { value: 0 },
            uTreble: { value: 0 },
          },
          vertexShader: document.getElementById("vertexShader").textContent,
          fragmentShader: document.getElementById("fragmentShader").textContent,
        });

        scene.add(new THREE.Mesh(geometry, material));

        renderer = new THREE.WebGLRenderer({ antialias: true });
        const dpr = Math.min(window.devicePixelRatio, 2);
        renderer.setPixelRatio(dpr);
        renderer.setSize(window.innerWidth, window.innerHeight);
        material.uniforms.uResolution.value.set(window.innerWidth * dpr, window.innerHeight * dpr);
        document.body.appendChild(renderer.domElement);

        window.addEventListener("resize", () => {
          const dpr = Math.min(window.devicePixelRatio, 2);
          renderer.setSize(window.innerWidth, window.innerHeight);
          material.uniforms.uResolution.value.set(window.innerWidth * dpr, window.innerHeight * dpr);
        });

        window.addEventListener("mousemove", (e) => {
          targetMouse.x = (e.clientX / window.innerWidth) * 2 - 1;
          targetMouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });
      }

      async function initAudio() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioContext.createMediaStreamSource(stream);
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 512;
          source.connect(analyser);
          dataArray = new Uint8Array(analyser.frequencyBinCount);
          return true;
        } catch (err) {
          console.error("Audio Access Denied:", err);
          return false;
        }
      }

      function animate(time) {
        requestAnimationFrame(animate);

        if (analyser) {
          analyser.getByteFrequencyData(dataArray);
          let b = 0,
            t = 0,
            s = 0;
          const len = dataArray.length;

          for (let i = 0; i < 15; i++) b += dataArray[i];
          for (let i = Math.floor(len * 0.7); i < len; i++) t += dataArray[i];
          for (let i = 0; i < len; i++) s += dataArray[i];

          smoothBass += (b / 15 / 255 - smoothBass) * 0.12;
          smoothTreble += (t / (len * 0.3) / 255 - smoothTreble) * 0.15;
          smoothIntensity += (s / len / 255 - smoothIntensity) * 0.1;

          material.uniforms.uBass.value = smoothBass;
          material.uniforms.uTreble.value = smoothTreble;
          material.uniforms.uAudioIntensity.value = smoothIntensity;
        }

        mouse.lerp(targetMouse, 0.05);
        material.uniforms.uMouse.value.copy(mouse);
        material.uniforms.uTime.value = time * 0.001;
        renderer.render(scene, camera);
      }

      document.getElementById("overlay").addEventListener("click", async () => {
        if (await initAudio()) {
          document.getElementById("overlay").classList.add("hidden");
          initScene();
          animate(0);
        }
      });
    </script>
  </body>
</html>
